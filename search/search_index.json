{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Gaztaroa App This is the documentation for the Gaztaroa App.","title":"Home"},{"location":"#welcome-to-gaztaroa-app","text":"This is the documentation for the Gaztaroa App.","title":"Welcome to Gaztaroa App"},{"location":"1_react_native/","text":"React Native. First steps This project is a sample project created with JavaScript and React Native for native development ( Android and iOS ). Additional tools used during the development process are next: Git (VCS) Trello (Project management tool) NodeJS (JavaScript runtime for server-side development) NPM (Package manager for the NodeJS platform) Yarn (Package manager) Expo (Platform for making universal native apps for Android, iOS and and the web with JS and React) Native App Development term refers to building a mobile app exclusively for a single platform. The app is built with programming languages and tools that are specific to a single platform. React Native React Native is used in this project for native app development. Native resources are accessed and managed in JavaScript and using React core concepts. Once the app is fully developed, it can be compiled to platform-specific app (Android and iOS). React Native is like React, but it uses native components instead of web components as building blocks. So to understand the basic structure of a React Native app, you need to understand some of the basic React concepts, like JSX, components, state , and props . Expo In this project Expo is used together with React Native for native development. Expo CLI tool expo-cli can be used for building and configuring first React Native project. Additionally, the Expo client for Android and iOS provides an interactive interface for app debugging and testing during the development process. Expo is an open-source platform for making universal native apps for Android, iOS, and the web with JavaScript and React. Both, the React Native Javascript framework for native development and the Expo platform, make up the development environment for this sample project. Most of the time, both environments integrate adequately and facilitate the development, however many functionalities require deep knowledge on both ecosystems to avoid conflicts. Main problems encountered have to do with some modules configuration and project dependencies.","title":"React Native"},{"location":"1_react_native/#react-native-first-steps","text":"This project is a sample project created with JavaScript and React Native for native development ( Android and iOS ). Additional tools used during the development process are next: Git (VCS) Trello (Project management tool) NodeJS (JavaScript runtime for server-side development) NPM (Package manager for the NodeJS platform) Yarn (Package manager) Expo (Platform for making universal native apps for Android, iOS and and the web with JS and React) Native App Development term refers to building a mobile app exclusively for a single platform. The app is built with programming languages and tools that are specific to a single platform.","title":"React Native. First steps"},{"location":"1_react_native/#react-native","text":"React Native is used in this project for native app development. Native resources are accessed and managed in JavaScript and using React core concepts. Once the app is fully developed, it can be compiled to platform-specific app (Android and iOS). React Native is like React, but it uses native components instead of web components as building blocks. So to understand the basic structure of a React Native app, you need to understand some of the basic React concepts, like JSX, components, state , and props .","title":"React Native"},{"location":"1_react_native/#expo","text":"In this project Expo is used together with React Native for native development. Expo CLI tool expo-cli can be used for building and configuring first React Native project. Additionally, the Expo client for Android and iOS provides an interactive interface for app debugging and testing during the development process. Expo is an open-source platform for making universal native apps for Android, iOS, and the web with JavaScript and React. Both, the React Native Javascript framework for native development and the Expo platform, make up the development environment for this sample project. Most of the time, both environments integrate adequately and facilitate the development, however many functionalities require deep knowledge on both ecosystems to avoid conflicts. Main problems encountered have to do with some modules configuration and project dependencies.","title":"Expo"},{"location":"2_react_native_components/","text":"React Native Components React Components let you split the UI into independent, reusable pieces, and think about each piece in isolation. Components are core concepts from React. Unlike in React, where components represent HTML objects, in React Native components represent native elements that are transformed to platform-specific objects at build. This helps building platform-independent apps, while using independent reusable components for UI. React allows to define components as JavaScript classes class components or functions functional components . Class components provide more features than functional components, however, React Hooks can extend these capabilities. Components accept inputs called props and can store their own state , which is used to re-render the view when changed. props are used as input data to components. It allows particularizing view elements, as well as conditional rendering based on these values. This architecture allows implementing reusable code and designing nested components hierarchy to render complex views. Component's state management provides an intuitive and efficient way to render updated UI views while keeping the ones that don't change. For this project, all component definitions are stored under /components folder in Rect app. Class Components Class Components extend React.Component and must implement render() function to return the view to be rendered in the screen. When called, it should examine this.props and this.state and return one of the following types: React elements (optionally with JSX ) Arrays and fragments Portals String and numbers Booleans or null Functional Components Functional Components in React return React elements as JavaScript functions. They accept props as inputs to use on render view. React Hooks extend base functionalities for functional components, providing state and more. Component Lifecycle Component Lifecycle refers to special methods on the component class invoked when the component mounts ( componentDidMount() ) and unmounts ( componentWillUnmount() ). We use this methods to interact with the browser and external resources while using render() exclusively to return render elements. The component state should not be udated inside render() method, separating rendering from all other programming logic. Both types of components are used in this project. Generally, functional components are used for simple UI elements, while more complex ones are implemented as class components. Additionally, many components are nested to create more complex views. At first, components seem to be the easy and correct way to build the app and store the state. This is true, however there are many key aspects to come across while using small independent components related to data and the model. props can be passed down from one component to another in a nested level hierarchy, what makes it tedious work. This can be fixed with advanced React features such as Context . Other example related to state is that it is private to the component itself, so there isn't a single data source. Distributing the app state and data model into different components makes it difficult to mantain. To fix this problems, some of the approaches used are State Lifting and Redux .","title":"Components"},{"location":"2_react_native_components/#react-native-components","text":"React Components let you split the UI into independent, reusable pieces, and think about each piece in isolation. Components are core concepts from React. Unlike in React, where components represent HTML objects, in React Native components represent native elements that are transformed to platform-specific objects at build. This helps building platform-independent apps, while using independent reusable components for UI. React allows to define components as JavaScript classes class components or functions functional components . Class components provide more features than functional components, however, React Hooks can extend these capabilities. Components accept inputs called props and can store their own state , which is used to re-render the view when changed. props are used as input data to components. It allows particularizing view elements, as well as conditional rendering based on these values. This architecture allows implementing reusable code and designing nested components hierarchy to render complex views. Component's state management provides an intuitive and efficient way to render updated UI views while keeping the ones that don't change. For this project, all component definitions are stored under /components folder in Rect app.","title":"React Native Components"},{"location":"2_react_native_components/#class-components","text":"Class Components extend React.Component and must implement render() function to return the view to be rendered in the screen. When called, it should examine this.props and this.state and return one of the following types: React elements (optionally with JSX ) Arrays and fragments Portals String and numbers Booleans or null","title":"Class Components"},{"location":"2_react_native_components/#functional-components","text":"Functional Components in React return React elements as JavaScript functions. They accept props as inputs to use on render view. React Hooks extend base functionalities for functional components, providing state and more.","title":"Functional Components"},{"location":"2_react_native_components/#component-lifecycle","text":"Component Lifecycle refers to special methods on the component class invoked when the component mounts ( componentDidMount() ) and unmounts ( componentWillUnmount() ). We use this methods to interact with the browser and external resources while using render() exclusively to return render elements. The component state should not be udated inside render() method, separating rendering from all other programming logic. Both types of components are used in this project. Generally, functional components are used for simple UI elements, while more complex ones are implemented as class components. Additionally, many components are nested to create more complex views. At first, components seem to be the easy and correct way to build the app and store the state. This is true, however there are many key aspects to come across while using small independent components related to data and the model. props can be passed down from one component to another in a nested level hierarchy, what makes it tedious work. This can be fixed with advanced React features such as Context . Other example related to state is that it is private to the component itself, so there isn't a single data source. Distributing the app state and data model into different components makes it difficult to mantain. To fix this problems, some of the approaches used are State Lifting and Redux .","title":"Component Lifecycle"},{"location":"3_functional_components/","text":"Functional Components Functional components are JavaScript functions that return React elements to render view. props are passed to components as input data to use on render. By default functional components don't provide state and many other functionalities. React Hooks extend this basic capabilities: useState() : State useEffect() : Component Lifecycle Basic example import React, { useState, useEffect } from 'react'; function Example() { const [count, setCount] = useState(0); // Similar to componentDidMount and componentDidUpdate return ( <div> <p>You clicked {count} times</p> <button onClick={() => setCount(count + 1)}> Click me </button> </div> ); } Functional components are used for more simple component designs and nested inside other components to render complex views.","title":"Functional Components"},{"location":"3_functional_components/#functional-components","text":"Functional components are JavaScript functions that return React elements to render view. props are passed to components as input data to use on render. By default functional components don't provide state and many other functionalities. React Hooks extend this basic capabilities: useState() : State useEffect() : Component Lifecycle","title":"Functional Components"},{"location":"3_functional_components/#basic-example","text":"import React, { useState, useEffect } from 'react'; function Example() { const [count, setCount] = useState(0); // Similar to componentDidMount and componentDidUpdate return ( <div> <p>You clicked {count} times</p> <button onClick={() => setCount(count + 1)}> Click me </button> </div> ); } Functional components are used for more simple component designs and nested inside other components to render complex views.","title":"Basic example"},{"location":"4_stack_navigation/","text":"Stack Navigation A basic feature on native apps is the ability to navigate through screens. Navigation provides an interface to move on different views and components with integrated menus and links. React Native implements this functionality via Stack Navigator , Tab Navigator or Drawer Navigator . Basic Navigation example To configure navigation, Stack Navigation component from React Native must be used in stack scheme, through a hierarchy between different views of the application. Next, an example is shown: import * as React from 'react'; import { NavigationContainer } from '@react-navigation/native'; import { createNativeStackNavigator } from '@react-navigation/native-stack'; const Stack = createNativeStackNavigator(); const MyStack = () => { return ( <NavigationContainer> <Stack.Navigator> <Stack.Screen name=\"Home\" component={HomeScreen} options={{ title: 'Welcome' }} /> <Stack.Screen name=\"Profile\" component={ProfileScreen} /> </Stack.Navigator> </NavigationContainer> ); }; The example shows 2 screens ( Home and Profile ) using Stack.Screen components inside a Stack.Navigator component. In addition, we need to wrap the whole app in NavigationContainer . Options can be passed to screens in the options prop of component Stack.Screen . Each screen also takes a component prop that is a React component to render. This components receive a prop called navigation which has various methods to link to other screens. As an example: const HomeScreen = ({ navigation }) => { return ( <Button title=\"Go to Jane's profile\" onPress={() => navigation.navigate('Profile', { name: 'Jane' }) } /> ); }; const ProfileScreen = ({ navigation, route }) => { return <Text>This is {route.params.name}'s profile</Text>; }; This navigation scheme allows to design different levels of views to organize the app into, while providing modularity to the code. Additionally, many navigator components can be nested in order to build complex navigation schemes. In the current sample application, Drawer Navigator is used on top of the app, while Stack Navigator is used deeper in the hierarchy to switch between specific components.","title":"Stack Navigation"},{"location":"4_stack_navigation/#stack-navigation","text":"A basic feature on native apps is the ability to navigate through screens. Navigation provides an interface to move on different views and components with integrated menus and links. React Native implements this functionality via Stack Navigator , Tab Navigator or Drawer Navigator .","title":"Stack Navigation"},{"location":"4_stack_navigation/#basic-navigation-example","text":"To configure navigation, Stack Navigation component from React Native must be used in stack scheme, through a hierarchy between different views of the application. Next, an example is shown: import * as React from 'react'; import { NavigationContainer } from '@react-navigation/native'; import { createNativeStackNavigator } from '@react-navigation/native-stack'; const Stack = createNativeStackNavigator(); const MyStack = () => { return ( <NavigationContainer> <Stack.Navigator> <Stack.Screen name=\"Home\" component={HomeScreen} options={{ title: 'Welcome' }} /> <Stack.Screen name=\"Profile\" component={ProfileScreen} /> </Stack.Navigator> </NavigationContainer> ); }; The example shows 2 screens ( Home and Profile ) using Stack.Screen components inside a Stack.Navigator component. In addition, we need to wrap the whole app in NavigationContainer . Options can be passed to screens in the options prop of component Stack.Screen . Each screen also takes a component prop that is a React component to render. This components receive a prop called navigation which has various methods to link to other screens. As an example: const HomeScreen = ({ navigation }) => { return ( <Button title=\"Go to Jane's profile\" onPress={() => navigation.navigate('Profile', { name: 'Jane' }) } /> ); }; const ProfileScreen = ({ navigation, route }) => { return <Text>This is {route.params.name}'s profile</Text>; }; This navigation scheme allows to design different levels of views to organize the app into, while providing modularity to the code. Additionally, many navigator components can be nested in order to build complex navigation schemes. In the current sample application, Drawer Navigator is used on top of the app, while Stack Navigator is used deeper in the hierarchy to switch between specific components.","title":"Basic Navigation example"},{"location":"5_drawer_navigation/","text":"Drawer Navigation As presented in the previous section, navigation can also be implemented via Drawer Navigator component from React Native. This is a left (or right) sided drawer for navigating between screens. It can be dynamically opened or closed. In the current project, this Drawer Navigator is used as top level navigator for app wide navigation. It allows accessing main screen views from all over the application, as it is located on the left side of the screen. Basic Drawer Navigator example: import * as React from 'react'; import { Button, View } from 'react-native'; import { createDrawerNavigator } from '@react-navigation/drawer'; import { NavigationContainer } from '@react-navigation/native'; function HomeScreen({ navigation }) { return ( <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}> <Button onPress={() => navigation.navigate('Notifications')} title=\"Go to notifications\" /> </View> ); } function NotificationsScreen({ navigation }) { return ( <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}> <Button onPress={() => navigation.goBack()} title=\"Go back home\" /> </View> ); } const Drawer = createDrawerNavigator(); export default function App() { return ( <NavigationContainer> <Drawer.Navigator initialRouteName=\"Home\"> <Drawer.Screen name=\"Home\" component={HomeScreen} /> <Drawer.Screen name=\"Notifications\" component={NotificationsScreen} /> </Drawer.Navigator> </NavigationContainer> ); }","title":"Drawer Navigation"},{"location":"5_drawer_navigation/#drawer-navigation","text":"As presented in the previous section, navigation can also be implemented via Drawer Navigator component from React Native. This is a left (or right) sided drawer for navigating between screens. It can be dynamically opened or closed. In the current project, this Drawer Navigator is used as top level navigator for app wide navigation. It allows accessing main screen views from all over the application, as it is located on the left side of the screen. Basic Drawer Navigator example: import * as React from 'react'; import { Button, View } from 'react-native'; import { createDrawerNavigator } from '@react-navigation/drawer'; import { NavigationContainer } from '@react-navigation/native'; function HomeScreen({ navigation }) { return ( <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}> <Button onPress={() => navigation.navigate('Notifications')} title=\"Go to notifications\" /> </View> ); } function NotificationsScreen({ navigation }) { return ( <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}> <Button onPress={() => navigation.goBack()} title=\"Go back home\" /> </View> ); } const Drawer = createDrawerNavigator(); export default function App() { return ( <NavigationContainer> <Drawer.Navigator initialRouteName=\"Home\"> <Drawer.Screen name=\"Home\" component={HomeScreen} /> <Drawer.Screen name=\"Notifications\" component={NotificationsScreen} /> </Drawer.Navigator> </NavigationContainer> ); }","title":"Drawer Navigation"},{"location":"6_component_navigation/","text":"Component Navigation Navigation in React Native allows to easily add views to app and navigate between them. It provides different Navigator components for custom menus, as well as a modular interface for such purpose. Stack Navigator Tab Navigator Drawer Navigator","title":"Component Navigation"},{"location":"6_component_navigation/#component-navigation","text":"Navigation in React Native allows to easily add views to app and navigate between them. It provides different Navigator components for custom menus, as well as a modular interface for such purpose. Stack Navigator Tab Navigator Drawer Navigator","title":"Component Navigation"},{"location":"7_buttons_icons/","text":"Buttons and Icons Basic interaction in an app is done with buttons. React Native provides a simple Button component for such purpose. However, same functionality can be accomplished via Icons and associated event actions. Button example: import { Button } from 'react-native'; <Button onPress={onPressLearnMore} title=\"Learn More\" color=\"#841584\" accessibilityLabel=\"Learn more about this purple button\" /> Icon example: import { Icon } from 'react-native-elements' <Icon raised name='heartbeat' type='font-awesome' color='#f50' onPress={() => console.log('hello')} /> In the app, icons are used for \"favorites\" feature. When the icon first pressed, it changes the appearance to warn the user. The onPress event action changes the component state so it renders the updated icon. Additionally, when the button gets pressed the second time, it raises a warning message to console to indicate it was already pressed. Font Awesome is one of the most used Internet's icon library and toolkit and Icon component from React Native Elements integrates it. Notes At this point \"favorites\" feature is implemented using a component's state, so it is not persisted for future sessions. Even more, it exists during the component lifecycle and lost when the component gets unmounted. It may be interesting to persist user-selected \"favorites\" and fetch them at app startup so the user can restore them. React core Components such as Buttons and Icons can be custommized using inline stylesheet components passed to prop called style . This stylesheet usually match CSS. Example of use: import React from 'react'; import { StyleSheet, Text, View } from 'react-native'; const LotsOfStyles = () => { return ( <View style={styles.container}> <Text style={styles.red}>just red</Text> <Text style={styles.bigBlue}>just bigBlue</Text> <Text style={[styles.bigBlue, styles.red]}>bigBlue, then red</Text> <Text style={[styles.red, styles.bigBlue]}>red, then bigBlue</Text> </View> ); }; const styles = StyleSheet.create({ container: { marginTop: 50, }, bigBlue: { color: 'blue', fontWeight: 'bold', fontSize: 30, }, red: { color: 'red', }, }); export default LotsOfStyles;","title":"Buttons and Icons"},{"location":"7_buttons_icons/#buttons-and-icons","text":"Basic interaction in an app is done with buttons. React Native provides a simple Button component for such purpose. However, same functionality can be accomplished via Icons and associated event actions. Button example: import { Button } from 'react-native'; <Button onPress={onPressLearnMore} title=\"Learn More\" color=\"#841584\" accessibilityLabel=\"Learn more about this purple button\" /> Icon example: import { Icon } from 'react-native-elements' <Icon raised name='heartbeat' type='font-awesome' color='#f50' onPress={() => console.log('hello')} /> In the app, icons are used for \"favorites\" feature. When the icon first pressed, it changes the appearance to warn the user. The onPress event action changes the component state so it renders the updated icon. Additionally, when the button gets pressed the second time, it raises a warning message to console to indicate it was already pressed. Font Awesome is one of the most used Internet's icon library and toolkit and Icon component from React Native Elements integrates it.","title":"Buttons and Icons"},{"location":"7_buttons_icons/#notes","text":"At this point \"favorites\" feature is implemented using a component's state, so it is not persisted for future sessions. Even more, it exists during the component lifecycle and lost when the component gets unmounted. It may be interesting to persist user-selected \"favorites\" and fetch them at app startup so the user can restore them. React core Components such as Buttons and Icons can be custommized using inline stylesheet components passed to prop called style . This stylesheet usually match CSS. Example of use: import React from 'react'; import { StyleSheet, Text, View } from 'react-native'; const LotsOfStyles = () => { return ( <View style={styles.container}> <Text style={styles.red}>just red</Text> <Text style={styles.bigBlue}>just bigBlue</Text> <Text style={[styles.bigBlue, styles.red]}>bigBlue, then red</Text> <Text style={[styles.red, styles.bigBlue]}>red, then bigBlue</Text> </View> ); }; const styles = StyleSheet.create({ container: { marginTop: 50, }, bigBlue: { color: 'blue', fontWeight: 'bold', fontSize: 30, }, red: { color: 'red', }, }); export default LotsOfStyles;","title":"Notes"},{"location":"8_json_server/","text":"JSON Server React is a JavaScript framework, so it integrates its data model and features. JSON (JavaScript Object Notation) is a lightweight data-interchange format. It stores data as human-readable text and provides support for main data types. It is widely used as it is completely language independent. To persistent data storage we will be using a JSON database server that provides data in JSON format via REST API. It differs from traditional SQL databases (relational databases, table-based), as these are non-relational and file-based. This data storage method eases fast data accessing and manipulation. Other resources may also be provided by online servers as images. The current implementation for JSON server is installed via NPM. To start the server run next command. json-server --host <host_ip> <json_file> -p <port> -d <delay_ms> Hosting resources in online centralized servers allow app scalability, as contents can be dynamically fetched and rendered to the user, and must not be distributed and updated within the app. On the other hand, resources must be available at the time the app queries for them. For this reason, the app logo image is loaded locally, while other images are fetched from the server.","title":"JSON Server"},{"location":"8_json_server/#json-server","text":"React is a JavaScript framework, so it integrates its data model and features. JSON (JavaScript Object Notation) is a lightweight data-interchange format. It stores data as human-readable text and provides support for main data types. It is widely used as it is completely language independent. To persistent data storage we will be using a JSON database server that provides data in JSON format via REST API. It differs from traditional SQL databases (relational databases, table-based), as these are non-relational and file-based. This data storage method eases fast data accessing and manipulation. Other resources may also be provided by online servers as images. The current implementation for JSON server is installed via NPM. To start the server run next command. json-server --host <host_ip> <json_file> -p <port> -d <delay_ms> Hosting resources in online centralized servers allow app scalability, as contents can be dynamically fetched and rendered to the user, and must not be distributed and updated within the app. On the other hand, resources must be available at the time the app queries for them. For this reason, the app logo image is loaded locally, while other images are fetched from the server.","title":"JSON Server"},{"location":"9_redux_thunk/","text":"Redux and Thunk One of the obvious limitation of the current implementation is the app state management, as the state in React is private to the component itself and not accessible from outside. Some techniques as State Lifting or Context solve this problem in a shallow way, but do not scale for bigger apps. For this purpose, we use Redux. Redux Redux is a predictable state container for JavaScript apps. Redux is an implementation of Flux architecture in JavaScript. It works as unidirectional data flow implementation. It provides predictability and traceability, while facilitating any other modification. Redux integrates 3 fundamentals: Single source of trust State is read-only Changes are performed on pure functions Appart from Redux, we will be using Redux-Thunk as middleware to perform asynchronous requests to the database and Redux-Logger to show app logs on console. Redux Store All the app state is stored in a tree inside a single store. The function createStore() creates the React Store where combineReducers() combines independent reducers to act as single. Additionally, both middlewares are assigned to the store in the configuration step. ConfigureStore() shows the store configuration: export const ConfigureStore = () => { const store = createStore( combineReducers({ excursiones, comentarios, cabeceras, actividades }), applyMiddleware(thunk, logger) ); return store; } Action types Define available actions for Redux data repositories ( reducers ). Reducers Reducers are Redux respositories that compose Redux store (trips, headers, activities, comments). The goal of the reducers is to update the state based on the action triggered. Redux-Thunk Thunk middleware for Redux. It allows writing functions with logic inside that can interact with a Redux store's dispatch and getState methods. Provide an API to perform asynchronous queries to database. Action Creators Functions (Thunk) and actions that will respond to the app requirements. As they are implemented based on asynchronous requests, they will manage promise objects using dispatch() function. In this case, they will perform queries to REST API from JSON server.","title":"Redux and Thunk"},{"location":"9_redux_thunk/#redux-and-thunk","text":"One of the obvious limitation of the current implementation is the app state management, as the state in React is private to the component itself and not accessible from outside. Some techniques as State Lifting or Context solve this problem in a shallow way, but do not scale for bigger apps. For this purpose, we use Redux.","title":"Redux and Thunk"},{"location":"9_redux_thunk/#redux","text":"Redux is a predictable state container for JavaScript apps. Redux is an implementation of Flux architecture in JavaScript. It works as unidirectional data flow implementation. It provides predictability and traceability, while facilitating any other modification. Redux integrates 3 fundamentals: Single source of trust State is read-only Changes are performed on pure functions Appart from Redux, we will be using Redux-Thunk as middleware to perform asynchronous requests to the database and Redux-Logger to show app logs on console.","title":"Redux"},{"location":"9_redux_thunk/#redux-store","text":"All the app state is stored in a tree inside a single store. The function createStore() creates the React Store where combineReducers() combines independent reducers to act as single. Additionally, both middlewares are assigned to the store in the configuration step. ConfigureStore() shows the store configuration: export const ConfigureStore = () => { const store = createStore( combineReducers({ excursiones, comentarios, cabeceras, actividades }), applyMiddleware(thunk, logger) ); return store; }","title":"Redux Store"},{"location":"9_redux_thunk/#action-types","text":"Define available actions for Redux data repositories ( reducers ).","title":"Action types"},{"location":"9_redux_thunk/#reducers","text":"Reducers are Redux respositories that compose Redux store (trips, headers, activities, comments). The goal of the reducers is to update the state based on the action triggered.","title":"Reducers"},{"location":"9_redux_thunk/#redux-thunk","text":"Thunk middleware for Redux. It allows writing functions with logic inside that can interact with a Redux store's dispatch and getState methods. Provide an API to perform asynchronous queries to database.","title":"Redux-Thunk"},{"location":"9_redux_thunk/#action-creators","text":"Functions (Thunk) and actions that will respond to the app requirements. As they are implemented based on asynchronous requests, they will manage promise objects using dispatch() function. In this case, they will perform queries to REST API from JSON server.","title":"Action Creators"}]}